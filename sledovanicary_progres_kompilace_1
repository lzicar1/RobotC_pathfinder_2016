//MUSTR
#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          pravy,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          levy,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          madlo,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//touch = S1
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

#define ZAKLAD -5.0//zakladni rychlost na care

#define KP 0.5
#define KD 10

#define ELEMENT 1

int hrana = 50; //vzdy dosad nove


void preambule()
{
   clearTimer(T1);
   clearDebugStream();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);

   writeDebugStreamLine(",n, odchylka, derivativ, zaklad");

}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
float vystup_avg = 1;

float avg_exp(float K_AVG, float vstup)
{

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}

task sledovanicary()
{

//rekurzivniokenko
   float posledniodchylka = 0;
   unsigned long n = 1;
   float g = 1;

   while (1)
   {
      //PID
   float hsenzoru = avg_exp(6, getColorReflected(S3));
      //korekce uhlove rychlosti robota
      float zaklad = ZAKLAD; //- getGyroRate(S2)*(ZAKLAD/100);

      bool rovina = false;
      bool klidek = false;

      if (getGyroRate(S2) < 30 && getGyroRate(S2) > -30)
     	{
				klidek = true;
				g = g +0.5;

     	}

      else if (getGyroRate(S2) < 15 && getGyroRate(S2) > -15)
     	{
				g = g +1;

     	} else {
     	  g =0;
     	}


     	if (g > 5)
     	{
    			rovina = true;
    			zaklad += 30 + g*0.01;
     	}

     	if (rovina == true && klidek == false)
     	{
     		zaklad -= 30;
     	}

     	    float kp = KP;
    			float kd = KD;


     	float odchylka = hrana - hsenzoru;
      float derivativ = odchylka - posledniodchylka;
      float rychlost_pid = odchylka * kp + derivativ * kd;

      //madlo by mÃ„:lo sledovat caru

      float rychlostA = zaklad + rychlost_pid;
      float rychlostB = zaklad - rychlost_pid;

      if(rychlostA > 100){rychlostA = 100;} //if(rychlostA < 0){rychlostA = 0;}
      if(rychlostB > 100){rychlostB = 100;} //if(rychlostB < 0){rychlostB = 0;}

      setMotorSpeed(motorA, rychlostA);
      setMotorSpeed(motorB, rychlostB);


      sleep(3);

      posledniodchylka = odchylka;
      n = n+1;

  		writeDebugStreamLine("%f,%f,%f,%f,%f",n, odchylka, derivativ, zaklad);
   }
}


task main()
{
  preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }
}
