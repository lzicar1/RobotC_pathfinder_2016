
//MUSTR
#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          pravy,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          levy,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          madlo,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ZAKLAD 20.0//zakladni rychlost na care

#define KP 0.2
#define KD 5

#define ELEMENT 1

int hrana = 55; //vzdy dosad nove

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

void preambule()
{
   clearTimer(T1);
   clearDebugStream();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);

   writeDebugStreamLine(",n, odchylka, derivativ, zaklad");

}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
float vystup_avg = 1;

float avg_exp(float avgk, float vstup)
{

   vystup_avg = vystup_avg + 1/avgk * (vstup - vystup_avg);
return vystup_avg;
}

#define RYCHLOST_ZATACKY 30
#define RYCHLOST_VYJEZDU_ZE_ZATACKY 50

void potencialnizatacka()
{
	if(getTouchValue(S1) == 1)
	{
		resetGyro(S2);
		repeatUntil(getGyroDegrees(S2) > 90)
		{
			setMotorSpeed(motorA, -1 * RYCHLOST_ZATACKY);
			setMotorSpeed(motorB, RYCHLOST_ZATACKY);
		}

		setMotorSpeed(motorA, RYCHLOST_VYJEZDU_ZE_ZATACKY);
		setMotorSpeed(motorB, RYCHLOST_VYJEZDU_ZE_ZATACKY);

		sleep(100);
	}
}

task sledovanicary()
{

//rekurzivniokenko
   float posledniodchylka = 0;
   unsigned long n = 1;
   float g = 1;

   bool klidek = false;
   bool rovina = false;
   bool zlom = false;

   while (1)
   {
     
   potencialnizatacka();
      //PID
   float hsenzoru = avg_exp(4, getColorReflected(S3));
      //korekce uhlove rychlosti robota
      float zaklad = ZAKLAD; //- getGyroRate(S2)*(ZAKLAD/100);

       if (getGyroRate(S2) < 30 && getGyroRate(S2) > -30)
     	{
				klidek = true;
				g = g +0.5;
				zaklad += g*0.03;

     	}

      else if (getGyroRate(S2) < 15 && getGyroRate(S2) > -15)
     	{
				g = g +1;

     	} else {
     	  g =0;
     	}

     	if (rovina == true && klidek == false)
     	{
     		zaklad -= g*0.03;
     	}


     	    float kp = KP;
    			float kd = KD;


     	float odchylka = hrana - hsenzoru;
      float derivativ = odchylka - posledniodchylka;
      float derivativ2 = derivativ*derivativ*derivativ*derivativ;
      float rychlost_pid = odchylka * kp + derivativ * kd;

      if(derivativ2 > 20 && zlom == false)
      	{
      		setMotorSyncTime(motorB, motorC, 0, 2000, 5);
      	//zlom = true;
      		playImmediateTone(440,10);

      	}

      //madlo by mÃ„:lo sledovat caru

      float rychlostC = zaklad + rychlost_pid;
      float rychlostB = zaklad - rychlost_pid;

      if(rychlostC > 100){rychlostC = 100;} //if(rychlostC < 0){rychlostC = 0;}
      if(rychlostB > 100){rychlostB = 100;} //if(rychlostB < 0){rychlostB = 0;}

      setMotorSpeed(motorC, rychlostC);
      setMotorSpeed(motorB, rychlostB);


      posledniodchylka = odchylka;
      n = n+1;

  		writeDebugStreamLine("%f,%f,%f,%f,%f",n, odchylka, derivativ, zaklad);
   }
}


task main()
{
  preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }
}
