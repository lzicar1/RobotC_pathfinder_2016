#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream");

#define SIRKA_ROBOTA 15 //Dopln
#define D_KOL 5.6 //(prumer v centimetrech) //Dopln
#define DOCASNY_ELEMENT 1

#define POZADI 0 
#define CARA 100
#define ROZLISENI_BARVY 15

#define ZAKLAD 30
#define RYCHLOST_OSCILACE_US 30

#define KP 2
#define KI 0
#define KD 0

#define K1 0.5 //korekce uhlu madla
#define K2 1 //korekce rychlosti kol podle uhlu madla
#define K3 0 //korekce rychlosti robota podle uhlove rychlosti

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4


float delka_jednoho_stupne = (PI * D_KOL)/360;
float hrana = (CARA + POZADI)/2;


void preambule()
{
   clearTimer(T1);
   resetAllSensorAutoID();
   clearDebugStream();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);

   writeDebugStreamLine("cas_sec, draha_robota, uhelRobota, odometrie_uhelrobota, X_souradnice, Y_souradnice");
}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
   float vystup_avg = 0;

float avg_exp(int K_AVG, float vstup)
{
   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}


task sledovanicary()
{

   setMotorSpeed(motorC, 50); //otoc madlo o -60Â° rychlosti 50%
   repeatUntil(getColorReflected(S3) < hrana + ROZLISENI_BARVY) //pockej dokud nenarazis na pravou hranu
   {
      sleep(1);
   }
   
//rekurzivniokenko
   float integral = 0;
   float posledniodchylka = 0;

   while (1)
   {
      //PID
   float hsenzoru = getColorReflected(S3);
      float odchylka = hrana - avg_exp(3, hsenzoru);
      float derivativ = odchylka - posledniodchylka;
      			integral = integral + hsenzoru;
      float rychlost_pid = odchylka * KP + integral * KI + derivativ * KD;

      //korekce uhlove rychlosti robota
      float uhlova_rychlost_robota = getGyroRate(S2);
      float zaklad = ZAKLAD + uhlova_rychlost_robota * K3;

      //madlo by mÄ:lo sledovat caru
      setMotorSpeed(motorC, rychlost_pid * K1);
      float uhelmadla = getMotorEncoder(motorC);

      setMotorSpeed(motorA, zaklad + uhelmadla * K2);
      setMotorSpeed(motorB, zaklad - uhelmadla * K2);

      sleep(5);


      posledniodchylka = odchylka;
   }
}


task main()
{
	preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }

   stopAllTasks();

}
