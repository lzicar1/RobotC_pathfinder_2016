#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          pravy,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          levy,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          madlo,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define ZAKLAD 20 //zakladni rychlost na care

#define KP 2
#define KI 0
#define KD 0

#define K1 0.5 //korekce uhlu madla
#define K2 1 //korekce rychlosti kol podle uhlu madla
#define K3 0 //korekce rychlosti robota podle uhlove rychlosti

#define K_PREVODU 40/24

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

int hrana = 35; //vzdy dosad nove

void preambule()
{
   clearTimer(T1);
   resetAllSensorAutoID();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);
}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
unsigned long n = 0;
float vystup_avg = 0;

float avg_exp(int K_AVG, float vstup)
{
  if(n < 3) //prvni tri iterace radeji nedelej nic
  {
    vystup_avg = vstup;
  }

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}

task sledovanicary()
{

   setMotorSpeed(motorC, -10); //otoc madlo rychlosti -5%
   repeatUntil(getColorReflected(S3) < 20) //pockej dokud nenarazis na pravou hranu
   {
      displayCenteredBigTextLine(3, "Hrana: %d", getColorReflected(S3));
      sleep(20);
   }
   sleep(1000);
   eraseDisplay();
   
//rekurzivniokenko
   float integral = 0;
   float posledniodchylka = 0;

   while (1)
   {
      //PID
   float hsenzoru = getColorReflected(S3);
      float odchylka = hrana - avg_exp(3, hsenzoru);
      float derivativ = odchylka - posledniodchylka;
            integral = (integral + hsenzoru)/3;
      float rychlost_pid = odchylka * KP + integral * KI + derivativ * KD;

      /*korekce uhlove rychlosti robota
      float uhlova_rychlost_robota = getGyroRate(S2);
      float zaklad = ZAKLAD + uhlova_rychlost_robota * K3;*/

      //madlo by mÃ„:lo sledovat caru
      setMotorSpeed(motorC, rychlost_pid);
      float uhelmadla = getMotorEncoder(motorC);

      /*
      setMotorSpeed(motorA, zaklad + uhelmadla * K2);
      setMotorSpeed(motorB, zaklad - uhelmadla * K2); */

      sleep(5);


      posledniodchylka = odchylka;
      n = n + 1;
   }
}


task main()
{
  preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }

   stopAllTasks();
}
