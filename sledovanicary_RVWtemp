#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ZAKLAD -5.0//zakladni rychlost na care

#define KP 0.4
#define KD 8

#define ELEMENT 1

int hrana = 50; //vzdy dosad nove

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

void preambule()
{
   clearTimer(T1);
   clearDebugStream();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);

   writeDebugStreamLine(",n, odchylka, derivativ, zaklad");

}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
float vystup_avg = 1;

float avg_exp(float K_AVG, float vstup)
{

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}

task sledovanicary()
{

//rekurzivniokenko
   float posledniodchylka = 0;
   unsigned long n = 1;
   float g = 1;

   while (1)
   {
      //PID
   float hsenzoru = avg_exp(6, getColorReflected(S3));
      //korekce uhlove rychlosti robota
      float zaklad = ZAKLAD; //- getGyroRate(S2)*(ZAKLAD/100);
      
      bool rovina = false;
      bool klidek = false;
      
      if (getGyroRate(S2) < 30 && getGyroRate(S2) > -30)
     	{
				klidek = true;	
				g = g +0.5;
				
     	}
      
      else if (getGyroRate(S2) < 15 && getGyroRate(S2) > -15)
     	{	
				g = g +1;
				
     	} else {
     	  g =0;
     	}
     		
     	
     	if (g > 5)
     	{
    			rovina = true;
    			zaklad += 30 + g*0.01;			
     	}
     		
     	if (rovina == true && klidek == false)
     	{
     		zaklad -= 30;
     	}
     	
     	    float kp = KP;
    			float kd = KD;
      
     	
     	float odchylka = hrana - hsenzoru;
      float derivativ = odchylka - posledniodchylka;
      float rychlost_pid = odchylka * kp + derivativ * kd;

      //madlo by mÄ:lo sledovat caru

      float rychlostC = zaklad + rychlost_pid;
      float rychlostB = zaklad - rychlost_pid;

      if(rychlostC > 100){rychlostC = 100;} //if(rychlostC < 0){rychlostC = 0;}
      if(rychlostB > 100){rychlostB = 100;} //if(rychlostB < 0){rychlostB = 0;}

      setMotorSpeed(motorC, rychlostC);
      setMotorSpeed(motorB, rychlostB);


      sleep(3);

      posledniodchylka = odchylka;
      n = n+1;

  		writeDebugStreamLine("%f,%f,%f,%f,%f",n, odchylka, derivativ, zaklad);
   }
}


task main()
{
  preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }
}

/*
#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ZAKLAD 20.0 //rychlost

#define KP 0.5
#define KD 10

#define ELEMENT 1

int hrana = 50; //vzdy dosad nove

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

void preambule()
{
   clearTimer(T1);
   clearDebugStream();

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);

   writeDebugStreamLine(",n, odchylka, derivativ, zaklad");

}


//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
float vystup_avg = 1;

float avg_exp(float K_AVG, float vstup)
{

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}

task sledovanicary()
{

//rekurzivniokenko
   float posledniodchylka = 0;
   unsigned long n = 1;
   float g = 1;

   while (1)
   {
      //PID
   float hsenzoru = avg_exp(6, getColorReflected(S3));
     
     //korekce uhlove rychlosti robota
      float zaklad = ZAKLAD- 2*getGyroRate(S2);

     	    float kp = KP;
    			float kd = KD;
      
     	
     	float odchylka = hrana - hsenzoru;
      float derivativ = odchylka - posledniodchylka;
       float derivativ2 = dervativ*derivativ;
       float derivativ4= deivativ*derivativ*deivativ*derivativ*0.5;
      float rychlost_pid = odchylka * kp + derivativ * kd;

      //madlo by mÄ:lo sledovat caru

      float rychlostC = zaklad + rychlost_pid;
      float rychlostB = zaklad - rychlost_pid;

      if(rychlostC > 100){rychlostC = 100;} //if(rychlostC < 0){rychlostC = 0;}
      if(rychlostB > 100){rychlostB = 100;} //if(rychlostB < 0){rychlostB = 0;}

      setMotorSpeed(motorC, rychlostC);
      setMotorSpeed(motorB, rychlostB);


      sleep(3);

      posledniodchylka = odchylka;
      n = n+1;

  		writeDebugStreamLine("%f,%f,%f,%f,%f", odhylka, derivativ, derivativ2,  derivativ4, avg_exp(10,derivativ);
   }
}


task main()
{
  preambule(); sleep(20);

   startTask(sledovanicary);

   while(1)
   {
      sleep(1);
   }
}

*/
