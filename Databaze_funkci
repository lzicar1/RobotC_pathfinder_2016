//MUSTR
#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          pravy,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          levy,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          madlo,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//touch = S1
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

void preambule()
{
   clearTimer(T1);

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);
   
   clearDebugStream();
   
   writeDebugStreamLine("getUSDistance(S4), cosDegrees(45), stena, odchylka, rychlost_pid");
}

//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
unsigned long n = 0;
float vystup_avg = 1;

float avg_exp(float K_AVG, float vstup)
{

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}


/********************************************/
//Predesle funkce jsou zkompilovane a funkcni
//Nasleduji ty, ktere je potreba zprovoznit
/********************************************/

#define RYCHLOST_ZATACKY 20
#define RYCHLOST_VYJEZDU_ZE_ZATACKY 60

void potencialnizatacka(int stupne)
{
	if(getTouchValue(S1) == 0)
	{
		displayCenteredBigTextLine(3, "potencialnizatacka()");
		resetGyro(S2);
		
		float odchylka = stupne - getGyroDegrees(S2);
   
		while (odchylka > 0 || odchylka < -0)
			{
				bFloatDuringInactiveMotorPWM = true;
				odchylka = stupne - getGyroDegrees(S2);
				if(getGyroDegrees(S2) < stupne)
					{
						setMotorSync(pravymotor, levyymotor, 100, RYCHLOST_ZATACKY + odchylka *0.5);  	
          }
					  
				if(getGyroDegrees(S2) > stupne)
					{
						setMotorSync(pravymotor, levyymotor, -100, RYCHLOST_ZATACKY +  odchylka *0.5); 
					}						
			}
              	 	
	 displayCenteredBigTextLine(3, "vyjezdzezatacky");
		sleep(3000) ; 
		setMotorSync(pravymotor, levyymotor, 0, RYCHLOST_VYJEZDU_ZE_ZATACKY);
  
         sleep(1000);
 	} 
}
/********************************************/

#define ROZPETI_OSCILACE 40 //stupnu

void hledej_caru()
{
	while(getColorReflected(S3) > hrana)
	{
		if(getMotorEncoder(motorC) < 0)
		{
			repeatUntil(getMotorEncoder(motorC) > ROZPETI_OSCILACE || getColorReflected(S3) < hrana)
			{
				setMotorSpeed(motorC, -30);
			}
		}

		if(getMotorEncoder(motorC) >= 0)
		{
			repeatUntil(getMotorEncoder(motorC) > -1 * ROZPETI_OSCILACE || getColorReflected(S3) < hrana)
			{
				setMotorSpeed(motorC, 30);
			}
		}

		sleep(5);
	}

}

/********************************************/

#define K_PREVODU 40/24

//okenko pro globalni promenne
int min = 100; int max = 0;

void kalibrace_light()
{
	displayTextLine(2, "KALIBRACE LS");
	displayTextLine(4, "Pro spusteni zmacknete enter");
	waitForButtonPress();
	eraseDisplay();

	setMotorTarget(motorC, 360 * K_PREVODU, 5);

	int rozsah = 10000;
	float hodnoty[rozsah];

	if(getMotorMoving(motorA) == 1)
	{
			for(int i; i<rozsah; i++)
			{
				hodnoty[i] = getColorAmbient(S3);
		
				if(hodnoty[i] < min)
				{
					min = hodnoty[i];
				}

				if(hodnoty[i] > max)
				{
					max = hodnoty[i];
				}

				sleep(3);
			}
	}

	displayCenteredTextLine(2, "KALIBRACE LS");
	displayTextLine(4, "Cerna: %d", min);
	displayTextLine(5, "Bila: %d", max);
	waitForButtonPress();
	eraseDisplay();
}

/********************************************/
