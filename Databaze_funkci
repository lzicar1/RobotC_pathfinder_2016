//MUSTR
#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          pravy,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          levy,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          madlo,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//madlo = motorC
//pravymotor = motorA
//levyymotor = motorB
//touch = S1
//senzor odrazeneho svetla = S3
//gyro senzor = S2
//ultrasonic = S4

void preambule()
{
   clearTimer(T1);

   resetMotorEncoder(motorA);
   resetMotorEncoder(motorB);
   resetMotorEncoder(motorC);
   
   clearDebugStream();
   
   writeDebugStreamLine("getUSDistance(S4), cosDegrees(45), stena, odchylka, rychlost_pid");
}

//odhad plovouciho prumeru s exponencialnim zapominanim... for fun
unsigned long n = 0;
float vystup_avg = 1;

float avg_exp(float K_AVG, float vstup)
{

   vystup_avg = vystup_avg + 1/K_AVG * (vstup - vystup_avg);
return vystup_avg;
}


/********************************************/
//Predesle funkce jsou zkompilovane a funkcni
//Nasleduji ty, ktere je potreba zprovoznit
/********************************************/

#define RYCHLOST_ZATACKY 30
#define RYCHLOST_VYJEZDU_ZE_ZATACKY 50

void potencialnizatacka()
{
	if(getTouchValue(S1) == 1)
	{
		resetGyro(S2);
		repeatUntil(getGyroDegrees(S2) > 90)
		{
			setMotorSpeed(motorA, -1 * RYCHLOST_ZATACKY);
			setMotorSpeed(motorB, RYCHLOST_ZATACKY);
		}

		setMotorSpeed(motorA, RYCHLOST_VYJEZDU_ZE_ZATACKY);
		setMotorSpeed(motorB, RYCHLOST_VYJEZDU_ZE_ZATACKY);

		sleep(100);
	}
}

/********************************************/

#define ROZPETI_OSCILACE 40 //stupnu

void hledej_caru()
{
	while(getColorReflected(S3) > hrana)
	{
		if(getMotorEncoder(motorC) < 0)
		{
			repeatUntil(getMotorEncoder(motorC) > ROZPETI_OSCILACE || getColorReflected(S3) < hrana)
			{
				setMotorSpeed(motorC, -30);
			}
		}

		if(getMotorEncoder(motorC) >= 0)
		{
			repeatUntil(getMotorEncoder(motorC) > -1 * ROZPETI_OSCILACE || getColorReflected(S3) < hrana)
			{
				setMotorSpeed(motorC, 30);
			}
		}

		sleep(5);
	}

}

/********************************************/

#define K_PREVODU 40/24

//okenko pro globalni promenne
int min = 100; int max = 0;

void kalibrace_light()
{
	displayTextLine(2, "KALIBRACE LS");
	displayTextLine(4, "Pro spusteni zmacknete enter");
	waitForButtonPress();
	eraseDisplay();

	setMotorTarget(motorC, 360 * K_PREVODU, 5);

	int rozsah = 10000;
	float hodnoty[rozsah];

	if(getMotorMoving(motorA) == 1)
	{
			for(int i; i<rozsah; i++)
			{
				hodnoty[i] = getColorAmbient(S3);
		
				if(hodnoty[i] < min)
				{
					min = hodnoty[i];
				}

				if(hodnoty[i] > max)
				{
					max = hodnoty[i];
				}

				sleep(3);
			}
	}

	displayCenteredTextLine(2, "KALIBRACE LS");
	displayTextLine(4, "Cerna: %d", min);
	displayTextLine(5, "Bila: %d", max);
	waitForButtonPress();
	eraseDisplay();
}

/********************************************/
